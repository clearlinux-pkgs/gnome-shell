From 08fbb5a1b3ba62ddaa261eaa4a1761604b04894c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Florian=20M=C3=BCllner?= <fmuellner@gnome.org>
Date: Wed, 23 Jan 2019 23:55:12 +0100
Subject: [PATCH 1/2] panel: Don't allow opening hidden menus via keybindings

We shouldn't allow toggling menus that aren't supported by the
current session mode, but as indicators are hidden rather than
destroyed on mode switches, it is not enough to check for an
indicator's existence.

https://gitlab.gnome.org/GNOME/gnome-shell/issues/851
---
 js/ui/panel.js | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/js/ui/panel.js b/js/ui/panel.js
index 1c6445a35..7481623e0 100644
--- a/js/ui/panel.js
+++ b/js/ui/panel.js
@@ -965,62 +965,62 @@ var Panel = new Lang.Class({
 
         let allowDrag = dragWindow.maximized_vertically &&
                         stageX > rect.x && stageX < rect.x + rect.width;
 
         if (!allowDrag)
             return Clutter.EVENT_PROPAGATE;
 
         global.display.begin_grab_op(dragWindow,
                                      Meta.GrabOp.MOVING,
                                      false, /* pointer grab */
                                      true, /* frame action */
                                      button,
                                      event.get_state(),
                                      event.get_time(),
                                      stageX, stageY);
 
         return Clutter.EVENT_STOP;
     },
 
     _onKeyPress(actor, event) {
         let symbol = event.get_key_symbol();
         if (symbol == Clutter.KEY_Escape) {
             global.display.focus_default_window(event.get_time());
             return Clutter.EVENT_STOP;
         }
 
         return Clutter.EVENT_PROPAGATE;
     },
 
     _toggleMenu(indicator) {
-        if (!indicator) // menu not supported by current session mode
-            return;
+        if (!indicator || !indicator.container.visible)
+            return; // menu not supported by current session mode
 
         let menu = indicator.menu;
         if (!indicator.actor.reactive)
             return;
 
         menu.toggle();
         if (menu.isOpen)
             menu.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
     },
 
     toggleAppMenu() {
         this._toggleMenu(this.statusArea.appMenu);
     },
 
     toggleCalendar() {
         this._toggleMenu(this.statusArea.dateMenu);
     },
 
     closeCalendar() {
         let indicator = this.statusArea.dateMenu;
         if (!indicator) // calendar not supported by current session mode
             return;
 
         let menu = indicator.menu;
         if (!indicator.actor.reactive)
             return;
 
         menu.close();
     },
 
-- 
2.18.1


From 91a66d1d9c7f7ad369d043a5b90731061be0459d Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 23 Jan 2019 15:59:42 -0500
Subject: [PATCH 2/2] shellActionModes: disable POPUP keybindings in unlock
 screen

Certain keybindings should continue to work even when a popup
menu is on screen. For instance, the keybinding for showing
the app menu and the keyinding for showing the calendar are
examples.

This is achieved by putting in place a special "POPUP" action
mode, whenever a popup menu is active.  This mode replaces
the (e.g., "NORMAL" or "OVERVIEW") action mode that was in place
for as long as the popup menu is active.

But those keybindings should not work when the user is at the
unlock dialog (which uses an action mode of "UNLOCK").

Unfortunately, since commit c79d24b6 they do.

This commit addresses the problem by forcing the action mode
to NONE at the unlock screen when popups are visible.

Closes https://gitlab.gnome.org/GNOME/gnome-shell/issues/851
---
 js/gdm/authPrompt.js  | 3 ++-
 js/gdm/loginDialog.js | 3 ++-
 js/ui/shellEntry.js   | 6 ++++--
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/js/gdm/authPrompt.js b/js/gdm/authPrompt.js
index fcb1a585b..960221917 100644
--- a/js/gdm/authPrompt.js
+++ b/js/gdm/authPrompt.js
@@ -1,43 +1,44 @@
 // -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 
 const Clutter = imports.gi.Clutter;
 const Gio = imports.gi.Gio;
 const Lang = imports.lang;
 const Pango = imports.gi.Pango;
 const Signals = imports.signals;
 const St = imports.gi.St;
 
 const Animation = imports.ui.animation;
 const Batch = imports.gdm.batch;
 const GdmUtil = imports.gdm.util;
 const Params = imports.misc.params;
+const Shell = imports.gi.Shell;
 const ShellEntry = imports.ui.shellEntry;
 const Tweener = imports.ui.tweener;
 const UserWidget = imports.ui.userWidget;
 
 var DEFAULT_BUTTON_WELL_ICON_SIZE = 16;
 var DEFAULT_BUTTON_WELL_ANIMATION_DELAY = 1.0;
 var DEFAULT_BUTTON_WELL_ANIMATION_TIME = 0.3;
 
 var MESSAGE_FADE_OUT_ANIMATION_TIME = 0.5;
 
 var AuthPromptMode = {
     UNLOCK_ONLY: 0,
     UNLOCK_OR_LOG_IN: 1
 };
 
 var AuthPromptStatus = {
     NOT_VERIFYING: 0,
     VERIFYING: 1,
     VERIFICATION_FAILED: 2,
     VERIFICATION_SUCCEEDED: 3
 };
 
 var BeginRequestType = {
     PROVIDE_USERNAME: 0,
     DONT_PROVIDE_USERNAME: 1
 };
 
 var AuthPrompt = new Lang.Class({
     Name: 'AuthPrompt',
 
@@ -99,7 +100,7 @@
                          x_align: St.Align.START });
         this._entry = new St.Entry({ style_class: 'login-dialog-prompt-entry',
                                      can_focus: true });
-        ShellEntry.addContextMenu(this._entry, { isPassword: true });
+        ShellEntry.addContextMenu(this._entry, { isPassword: true, actionMode: Shell.ActionMode.NONE });
 
         this.actor.add(this._entry,
                        { expand: true,
diff --git a/js/gdm/loginDialog.js b/js/gdm/loginDialog.js
index 16a8682e2..8b76f3a1d 100644
--- a/js/gdm/loginDialog.js
+++ b/js/gdm/loginDialog.js
@@ -315,61 +315,62 @@ var SessionMenuButton = new Lang.Class({
         this._button = new St.Button({ style_class: 'login-dialog-session-list-button',
                                        reactive: true,
                                        track_hover: true,
                                        can_focus: true,
                                        accessible_name: _("Choose Session"),
                                        accessible_role: Atk.Role.MENU,
                                        child: gearIcon });
 
         this.actor = new St.Bin({ child: this._button });
 
         let side = St.Side.TOP;
         let align = 0;
         if (Gdm.get_session_ids().length > _MAX_BOTTOM_MENU_ITEMS) {
             if (this.actor.text_direction == Clutter.TextDirection.RTL)
                 side = St.Side.RIGHT;
             else
                 side = St.Side.LEFT;
             align = 0.5;
         }
         this._menu = new PopupMenu.PopupMenu(this._button, align, side);
         Main.uiGroup.add_actor(this._menu.actor);
         this._menu.actor.hide();
 
         this._menu.connect('open-state-changed', (menu, isOpen) => {
              if (isOpen)
                  this._button.add_style_pseudo_class('active');
              else
                  this._button.remove_style_pseudo_class('active');
         });
 
-        this._manager = new PopupMenu.PopupMenuManager({ actor: this._button });
+        this._manager = new PopupMenu.PopupMenuManager({ actor: this._button },
+                                                       { actionMode: Shell.ActionMode.NONE });
         this._manager.addMenu(this._menu);
 
         this._button.connect('clicked', () => { this._menu.toggle(); });
 
         this._items = {};
         this._activeSessionId = null;
         this._populate();
     },
 
     updateSensitivity(sensitive) {
         this._button.reactive = sensitive;
         this._button.can_focus = sensitive;
         this._menu.close(BoxPointer.PopupAnimation.NONE);
     },
 
     _updateOrnament() {
         let itemIds = Object.keys(this._items);
         for (let i = 0; i < itemIds.length; i++) {
             if (itemIds[i] == this._activeSessionId)
                 this._items[itemIds[i]].setOrnament(PopupMenu.Ornament.DOT);
             else
                 this._items[itemIds[i]].setOrnament(PopupMenu.Ornament.NONE);
         }
     },
 
     setActiveSession(sessionId) {
          if (sessionId == this._activeSessionId)
              return;
 
          this._activeSessionId = sessionId;
diff --git a/js/ui/shellEntry.js b/js/ui/shellEntry.js
index 9db5136e6..09bb9bbd6 100644
--- a/js/ui/shellEntry.js
+++ b/js/ui/shellEntry.js
@@ -1,41 +1,42 @@
 // -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 
 const Clutter = imports.gi.Clutter;
 const Gtk = imports.gi.Gtk;
 const Lang = imports.lang;
 const St = imports.gi.St;
 
 const BoxPointer = imports.ui.boxpointer;
 const Main = imports.ui.main;
 const Params = imports.misc.params;
 const PopupMenu = imports.ui.popupMenu;
+const Shell = imports.gi.Shell;
 
 var EntryMenu = new Lang.Class({
     Name: 'ShellEntryMenu',
     Extends: PopupMenu.PopupMenu,
 
     _init(entry) {
         this.parent(entry, 0, St.Side.TOP);
 
         this._entry = entry;
         this._clipboard = St.Clipboard.get_default();
 
         // Populate menu
         let item;
         item = new PopupMenu.PopupMenuItem(_("Copy"));
         item.connect('activate', this._onCopyActivated.bind(this));
         this.addMenuItem(item);
         this._copyItem = item;
 
         item = new PopupMenu.PopupMenuItem(_("Paste"));
         item.connect('activate', this._onPasteActivated.bind(this));
         this.addMenuItem(item);
         this._pasteItem = item;
 
         this._passwordItem = null;
 
         Main.uiGroup.add_actor(this.actor);
         this.actor.hide();
     },
 
     _makePasswordItem() {
@@ -123,55 +124,56 @@ var EntryMenu = new Lang.Class({
 function _setMenuAlignment(entry, stageX) {
     let [success, entryX, entryY] = entry.transform_stage_point(stageX, 0);
     if (success)
         entry.menu.setSourceAlignment(entryX / entry.width);
 };
 
 function _onButtonPressEvent(actor, event, entry) {
     if (entry.menu.isOpen) {
         entry.menu.close(BoxPointer.PopupAnimation.FULL);
         return Clutter.EVENT_STOP;
     } else if (event.get_button() == 3) {
         let [stageX, stageY] = event.get_coords();
         _setMenuAlignment(entry, stageX);
         entry.menu.open(BoxPointer.PopupAnimation.FULL);
         return Clutter.EVENT_STOP;
     }
     return Clutter.EVENT_PROPAGATE;
 };
 
 function _onPopup(actor, entry) {
     let [success, textX, textY, lineHeight] = entry.clutter_text.position_to_coords(-1);
     if (success)
         entry.menu.setSourceAlignment(textX / entry.width);
     entry.menu.open(BoxPointer.PopupAnimation.FULL);
 };
 
 function addContextMenu(entry, params) {
     if (entry.menu)
         return;
 
-    params = Params.parse (params, { isPassword: false });
+    params = Params.parse (params, { isPassword: false, actionMode: Shell.ActionMode.POPUP });
 
     entry.menu = new EntryMenu(entry);
     entry.menu.isPassword = params.isPassword;
-    entry._menuManager = new PopupMenu.PopupMenuManager({ actor: entry });
+    entry._menuManager = new PopupMenu.PopupMenuManager({ actor: entry },
+                                                        { actionMode: params.actionMode });
     entry._menuManager.addMenu(entry.menu);
 
     // Add an event handler to both the entry and its clutter_text; the former
     // so padding is included in the clickable area, the latter because the
     // event processing of ClutterText prevents event-bubbling.
     entry.clutter_text.connect('button-press-event', (actor, event) => {
         _onButtonPressEvent(actor, event, entry);
     });
     entry.connect('button-press-event', (actor, event) => {
         _onButtonPressEvent(actor, event, entry);
     });
 
     entry.connect('popup-menu', actor => { _onPopup(actor, entry); });
 
     entry.connect('destroy', () => {
         entry.menu.destroy();
         entry.menu = null;
         entry._menuManager = null;
     });
 }
-- 
2.18.1

