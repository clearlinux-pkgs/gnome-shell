Add an AVX2 optimized blur function

--- gnome-shell-3.26.2/src/st/st-private.c.org	2018-03-26 16:28:27.385144999 +0000
+++ gnome-shell-3.26.2/src/st/st-private.c	2018-03-26 16:31:52.393634543 +0000
@@ -236,6 +236,115 @@
   return ret;
 }
 
+#pragma GCC push_options
+#pragma GCC target("avx2")
+
+static guchar *
+blur_pixels_avx2 (guchar  *pixels_in,
+             gint     width_in,
+             gint     height_in,
+             gint     rowstride_in,
+             gdouble  blur,
+             gint    *width_out,
+             gint    *height_out,
+             gint    *rowstride_out)
+{
+  guchar *pixels_out;
+  float   sigma;
+
+  /* The CSS specification defines (or will define) the blur radius as twice
+   * the Gaussian standard deviation. See:
+   *
+   * http://lists.w3.org/Archives/Public/www-style/2010Sep/0002.html
+   */
+  sigma = blur / 2.;
+
+  if ((guint) blur == 0)
+    {
+      *width_out  = width_in;
+      *height_out = height_in;
+      *rowstride_out = rowstride_in;
+      pixels_out = g_memdup (pixels_in, *rowstride_out * *height_out);
+    }
+  else
+    {
+      gdouble *kernel;
+      guchar  *line;
+      gint     n_values, half;
+      gint     x_in, y_in, x_out, y_out, i;
+
+      n_values = (gint) 5 * sigma;
+      half = n_values / 2;
+
+      *width_out  = width_in  + 2 * half;
+      *height_out = height_in + 2 * half;
+      *rowstride_out = (*width_out + 3) & ~3;
+
+      pixels_out = g_malloc0 (*rowstride_out * *height_out);
+      line       = g_malloc0 (*rowstride_out);
+
+      kernel = calculate_gaussian_kernel (sigma, n_values);
+
+      /* vertical blur */
+      for (x_in = 0; x_in < width_in; x_in++)
+        for (y_out = 0; y_out < *height_out; y_out++)
+          {
+            guchar *pixel_in, *pixel_out;
+            gint i0, i1;
+
+            y_in = y_out - half;
+
+            /* We read from the source at 'y = y_in + i - half'; clamp the
+             * full i range [0, n_values) so that y is in [0, height_in).
+             */
+            i0 = MAX (half - y_in, 0);
+            i1 = MIN (height_in + half - y_in, n_values);
+
+            pixel_in  =  pixels_in + (y_in + i0 - half) * rowstride_in + x_in;
+            pixel_out =  pixels_out + y_out * *rowstride_out + (x_in + half);
+
+            for (i = i0; i < i1; i++)
+              {
+                *pixel_out += *pixel_in * kernel[i];
+                pixel_in += rowstride_in;
+              }
+          }
+
+      /* horizontal blur */
+      for (y_out = 0; y_out < *height_out; y_out++)
+        {
+          memcpy (line, pixels_out + y_out * *rowstride_out, *rowstride_out);
+
+          for (x_out = 0; x_out < *width_out; x_out++)
+            {
+              gint i0, i1;
+              guchar *pixel_out, *pixel_in;
+
+              /* We read from the source at 'x = x_out + i - half'; clamp the
+               * full i range [0, n_values) so that x is in [0, width_out).
+               */
+              i0 = MAX (half - x_out, 0);
+              i1 = MIN (*width_out + half - x_out, n_values);
+
+              pixel_in  = line + x_out + i0 - half;
+              pixel_out = pixels_out + *rowstride_out * y_out + x_out;
+
+              *pixel_out = 0;
+              for (i = i0; i < i1; i++)
+                {
+                  *pixel_out += *pixel_in * kernel[i];
+                  pixel_in++;
+                }
+            }
+        }
+      g_free (kernel);
+      g_free (line);
+    }
+
+  return pixels_out;
+}
+
+#pragma GCC pop_options
 static guchar *
 blur_pixels (guchar  *pixels_in,
              gint     width_in,
@@ -249,6 +358,9 @@
   guchar *pixels_out;
   float   sigma;
 
+  if (__builtin_cpu_supports("avx2"))
+	return blur_pixels_avx2(pixels_in, width_in, height_in, rowstride_in, blur, width_out, height_out, rowstride_out);
+
   /* The CSS specification defines (or will define) the blur radius as twice
    * the Gaussian standard deviation. See:
    *
